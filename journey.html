<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Walter and Hrolf's: Journey to the Groomers</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
            background-color: #70c5ce; /* Sky blue background */
            position: relative;
        }
        canvas {
            background: #70c5ce;
            display: block;
        }
        /* Joystick Styles */
        #joystickContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            touch-action: none;
            display: none; /* Hidden initially */
        }
        #joystick {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
        }
        /* Action Buttons */
        #actionButtons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            touch-action: none;
            display: none; /* Hidden initially */
        }
        .actionButton {
            display: inline-block;
            width: 60px;
            height: 60px;
            margin-left: 20px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            text-align: center;
            line-height: 60px;
            font-size: 20px;
            color: #fff;
            user-select: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        .actionButton:hover {
            background: rgba(0,0,0,0.2);
        }
        /* UI for Barks and Collectibles */
        #barkCounter, #coinCounter, #powerUpCounter {
            position: fixed;
            top: 20px;
            right: 20px;
            color: black;
            font-size: 20px;
            z-index: 100;
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #coinCounter {
            top: 50px;
        }
        #powerUpCounter {
            top: 80px;
        }
        /* Start Screen */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #85d8cc; /* Semi-transparent sky blue */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #startScreen h1 {
            margin-top: 20px;
            font-size: 36px;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
        }

        .avatar-selection {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .avatar-selection .avatar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .avatar-selection img {
            width: 100px;
            height: 100px;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            background-color: #fff; /* Ensure SVGs have a background */
        }

        .avatar-selection img.selected {
            transform: scale(1.1);
            border-color: #FFD700; /* Gold border for selected avatar */
        }

        .avatar-name {
            margin-top: 5px;
            color: #fff;
            font-size: 18px;
            text-shadow: 1px 1px 2px #000;
            user-select: none;
        }

        #startButton {
            padding: 10px 20px;
            font-size: 24px;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: #fff;
            border-radius: 10px;
            transition: background-color 0.3s;
        }

        #startButton:hover {
            background-color: #45a049;
        }

        /* Game Over and Level Complete Screens */
        .overlayScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 30px 50px;
            border: 2px solid #fff;
            text-align: center;
            display: none;
            z-index: 150;
            border-radius: 10px;
        }

        .overlayScreen h1 {
            margin-bottom: 20px;
            color: #fff;
            font-size: 36px;
        }

        .overlayScreen p {
            margin-bottom: 20px;
            font-size: 20px;
            color: #fff;
        }

        .overlayScreen button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: #fff;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .overlayScreen button:hover {
            background-color: #45a049;
        }

        /* Enhanced Start Screen Logo Styles */
        #startScreen img {
            width: 200px;
            height: auto;
            margin-bottom: 20px; /* Adds spacing below the logo */
            z-index: 201; /* Ensures it's above other elements */
        }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="startScreen">
        <!-- Logo and Game Title -->
        <img src="https://www.walterhrolf.com/logo.svg" alt="Walter and Hrolf's: Journey to the Groomers" style="width: 200px; height: auto;">
        <h1>Journey to the Groomers</h1>
        
        <div class="avatar-selection">
            <!-- Avatar Containers with Names -->
            <div class="avatar-container">
                <!-- SVG Avatars as Data URIs -->
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjQwIiBmaWxsPSIjNjY2IiAvPgo8cGF0aCBkPSJNNTAsMTAwIEw3NSw4MCA1MCwxNTAgTDUwLDEwMCBaIiBmaWxsPSIjMzMzIiAvPgo8L3N2Zz4=" alt="Norwegian Elkhound" data-avatar="elkhound" title="Norwegian Elkhound">
                <div class="avatar-name">Hrolf</div>
            </div>
            <div class="avatar-container">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjQwIiBmaWxsPSIjRkQwMDUiIC8+CjxwYXRoIGQ9Ik01MCwxMDAgTDc1LDgwIDUwLDE1MCBMNTAwMTAxMDAgWiIgZmlsbD0iI0ZGMDAwIiAvPgo8L3N2Zz4=" alt="French Bulldog" data-avatar="frenchbulldog" title="French Bulldog">
                <div class="avatar-name">Walter</div>
            </div>
            <div class="avatar-container">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjQwIiBmaWxsPSIjMjIyIiAvPgo8cGF0aCBkPSJNNTAsMTAwIEw3NSw4MCA1MCwxNTAgTDUwLDEwMCBaIiBmaWxsPSIjMzMzIiAvPgo8L3N2Zz4=" alt="Standard Poodle" data-avatar="poodle" title="Standard Poodle">
                <div class="avatar-name">Jethro</div>
            </div>
        </div>
        <button id="startButton">Start Game</button>
    </div>

    <!-- Joystick Control -->
    <div id="joystickContainer">
        <div id="joystick"></div>
    </div>

    <!-- Action Buttons -->
    <div id="actionButtons">
        <div class="actionButton" id="jumpButton">▲</div>
        <div class="actionButton" id="shootButton">●</div>
    </div>

    <!-- UI Counters -->
    <div id="barkCounter"></div>
    <div id="coinCounter"></div>
    <div id="powerUpCounter"></div>

    <!-- Game Over Screen -->
    <div id="gameOver" class="overlayScreen">
        <h1>Game Over</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">Restart</button>
    </div>

    <!-- Level Complete Screen -->
    <div id="levelComplete" class="overlayScreen">
        <h1>Level Complete!</h1>
        <p>Your Score: <span id="levelScore">0</span></p>
        <button onclick="startNextLevel()">Next Level</button>
    </div>

    <!-- Canvas Element -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const avatarImages = document.querySelectorAll('.avatar-selection img');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const levelCompleteScreen = document.getElementById('levelComplete');
        const levelScoreElement = document.getElementById('levelScore');

        // Joystick and Action Buttons
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystick');
        const actionButtons = document.getElementById('actionButtons');
        const jumpButton = document.getElementById('jumpButton');
        const shootButton = document.getElementById('shootButton');

        // UI Counters
        const barkCounter = document.getElementById('barkCounter');
        const coinCounter = document.getElementById('coinCounter');
        const powerUpCounter = document.getElementById('powerUpCounter');

        // Game Variables
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        let gameSpeed = 3;
        let score = 0;
        let level = 1;

        // World Variables
        const baseWorldWidth = 5000; // Base width for the first level
        let worldWidth = baseWorldWidth; // Current level width
        let cameraX = 0;

        // Physics Variables (Enhanced Jump Mechanics)
        const gravity = 0.7; // Reduced gravity for smoother jumps
        const jumpVelocity = -20; // Increased jump velocity for higher jumps

        // Player object
        const player = {
            x: 50,
            y: canvasHeight - 150, // Adjusted to start on the ground
            width: 50,
            height: 50,
            speed: 7, // Increased speed for wider jumps
            velY: 0,
            jumping: false,
            grounded: false,
            invincible: false,
            invincibilityTimer: 0,
            image: null, // Will be set based on avatar selection
        };

        // Key Presses
        const keys = {};

        // Game State
        let gameState = 'start'; // 'start', 'playing', 'gameover', 'levelcomplete'

        // Platforms, Enemies, Barks, Collectibles, Power-Ups, Hazards Arrays
        let platforms = [];
        let enemies = [];
        let barks = []; // Renamed from bullets to barks
        let collectibles = [];
        let powerUps = [];
        let hazards = [];
        let finishLine;

        // Bark and Collectible Variables
        let barksAllowed = 3; // **Enabled from Level 1**
        let barksFired = 0;   // Number of barks fired in current level
        let coinsCollected = 0; // Number of coins collected
        let powerUpsCollected = 0; // Number of power-ups collected

        // Define Minimum Spacing Between Enemies
        const minEnemySpacing = 100; // **Reduced to allow closer enemy placement near start**

        // Maximum Jump Height Calculation
        const maxJumpTime = -jumpVelocity / gravity; // Time until velocity reaches 0
        const maxJumpHeight = jumpVelocity * maxJumpTime + 0.5 * gravity * maxJumpTime * maxJumpTime; // Using h = ut + 0.5at^2
        const MAX_PLATFORM_HEIGHT_DIFF = Math.abs(maxJumpHeight) + 30; // Increased buffer

        // Enemy (Cat) SVG Data URI
        const enemySVG = `
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 200 200"
            width="200"
            height="200">
            <!-- Body -->
            <path
                d="M50,120 Q40,80 80,70 Q120,60 140,100 Q160,140 100,150 Q40,160 50,120"
                fill="#000000"
                stroke="#333333"
                stroke-width="2" />
            
            <!-- Head -->
            <circle cx="100" cy="60" r="30" fill="#000000" stroke="#333333" stroke-width="2" />
            
            <!-- Eyes -->
            <ellipse cx="90" cy="55" rx="5" ry="8" fill="#FF0000" />
            <ellipse cx="110" cy="55" rx="5" ry="8" fill="#FF0000" />
            
            <!-- Pupils -->
            <circle cx="90" cy="55" r="2" fill="#000000" />
            <circle cx="110" cy="55" r="2" fill="#000000" />
            
            <!-- Pupils Glare -->
            <circle cx="88" cy="53" r="1" fill="#FFFFFF" />
            <circle cx="108" cy="53" r="1" fill="#FFFFFF" />
            
            <!-- Mouth -->
            <path d="M95,65 Q100,70 105,65" stroke="#FF0000" stroke-width="2" fill="none" />
            
            <!-- Fangs -->
            <line x1="100" y1="70" x2="95" y2="75" stroke="#FF0000" stroke-width="2" />
            <line x1="100" y1="70" x2="105" y2="75" stroke="#FF0000" stroke-width="2" />
            
            <!-- Whiskers -->
            <line x1="80" y1="60" x2="60" y2="55" stroke="#FFFFFF" stroke-width="1" />
            <line x1="80" y1="65" x2="60" y2="70" stroke="#FFFFFF" stroke-width="1" />
            <line x1="120" y1="60" x2="140" y2="55" stroke="#FFFFFF" stroke-width="1" />
            <line x1="120" y1="65" x2="140" y2="70" stroke="#FFFFFF" stroke-width="1" />
            
            <!-- Ears -->
            <polygon points="80,40 90,20 100,40" fill="#000000" stroke="#333333" stroke-width="2" />
            <polygon points="120,40 130,20 140,40" fill="#000000" stroke="#333333" stroke-width="2" />
            
            <!-- Claws -->
            <path
                d="M70,120 L60,130 M80,120 L70,130 M120,120 L130,130 M110,120 L120,130"
                stroke="#FFFFFF"
                stroke-width="2"
                fill="none" />
            
            <!-- Tail -->
            <path
                d="M150,100 Q160,90 150,80 Q140,70 145,60"
                stroke="#000000"
                stroke-width="4"
                fill="none"
                stroke-linecap="round" />
        </svg>
        `;
        const enemyImageSrc = 'data:image/svg+xml;base64,' + btoa(enemySVG.trim());

        // Finish Line SVG Data URI
        const finishLineSVG = `
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 400 300"
            width="400"
            height="300">
            
            <!-- Table Top -->
            <rect x="100" y="100" width="200" height="20" fill="#8B4513" />
            
            <!-- Padding on Table Top -->
            <rect x="100" y="100" width="200" height="20" fill="#CD853F" opacity="0.3" />
            
            <!-- Legs -->
            <!-- Front Left Leg -->
            <rect x="100" y="120" width="10" height="150" fill="#8B4513" />
            <!-- Front Right Leg -->
            <rect x="290" y="120" width="10" height="150" fill="#8B4513" />
            <!-- Back Left Leg -->
            <rect x="100" y="120" width="10" height="150" fill="#8B4513" />
            <!-- Back Right Leg -->
            <rect x="290" y="120" width="10" height="150" fill="#8B4513" />
            
            <!-- Reclining Surface -->
            <rect x="120" y="90" width="160" height="10" fill="#A0522D" transform="rotate(-10 200 90)" />
            
            <!-- Adjustable Handle -->
            <rect x="280" y="80" width="5" height="30" fill="#DAA520" />
            
            <!-- Simple Base -->
            <rect x="50" y="270" width="300" height="10" fill="#D3D3D3" />
            
        </svg>
        `;
        const finishLineImageSrc = 'data:image/svg+xml;base64,' + btoa(finishLineSVG.trim());

        // Grooming table image (replaced with SVG)
        const groomingTableImg = new Image();
        groomingTableImg.src = finishLineImageSrc; // Using the finish line SVG as grooming table

        // Dog avatars as SVG Data URIs
        const dogAvatars = {
            elkhound: 'data:image/svg+xml;base64,' + btoa(`
            <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 250 250"
                width="250"
                height="250">
                <!-- Body -->
                <path
                    d="M80,150 Q60,120 80,90 Q120,60 170,90 Q190,120 160,150 Q140,180 80,150"
                    fill="#A0522D"
                    stroke="#8B4513"
                    stroke-width="3" />
                
                <!-- Head -->
                <circle cx="125" cy="80" r="40" fill="#A0522D" stroke="#8B4513" stroke-width="3" />
                
                <!-- Ears -->
                <polygon points="100,60 90,30 110,50" fill="#A0522D" stroke="#8B4513" stroke-width="2" />
                <polygon points="150,60 160,30 140,50" fill="#A0522D" stroke="#8B4513" stroke-width="2" />
                
                <!-- Eyes -->
                <circle cx="110" cy="75" r="5" fill="#FFFFFF" />
                <circle cx="140" cy="75" r="5" fill="#FFFFFF" />
                <circle cx="110" cy="75" r="2" fill="#000000" />
                <circle cx="140" cy="75" r="2" fill="#000000" />
                
                <!-- Nose -->
                <circle cx="125" cy="90" r="4" fill="#000000" />
                
                <!-- Mouth -->
                <path d="M120,95 Q125,100 130,95" stroke="#000000" stroke-width="2" fill="none" />
                
                <!-- Fur Details -->
                <path
                    d="M90,110 Q80,100 90,90"
                    stroke="#8B4513"
                    stroke-width="2"
                    fill="none" />
                <path
                    d="M160,110 Q170,100 160,90"
                    stroke="#8B4513"
                    stroke-width="2"
                    fill="none" />
                
                <!-- Tail -->
                <path
                    d="M80,150 Q50,160 80,170"
                    stroke="#A0522D"
                    stroke-width="4"
                    fill="none"
                    stroke-linecap="round" />
                
                <!-- Legs -->
                <rect x="110" y="150" width="10" height="40" fill="#A0522D" stroke="#8B4513" stroke-width="2" />
                <rect x="130" y="150" width="10" height="40" fill="#A0522D" stroke="#8B4513" stroke-width="2" />
                
                <!-- Paws -->
                <circle cx="115" cy="190" r="3" fill="#8B4513" />
                <circle cx="135" cy="190" r="3" fill="#8B4513" />
                
                <!-- Collar -->
                <rect x="110" y="110" width="30" height="5" fill="#FFD700" stroke="#DAA520" stroke-width="1" />
            </svg>
            `),
            frenchbulldog: 'data:image/svg+xml;base64,' + btoa(`
            <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 200 200"
                width="200"
                height="200">
                <!-- Body -->
                <ellipse cx="100" cy="130" rx="50" ry="30" fill="#8B4513" />
                
                <!-- Head -->
                <circle cx="100" cy="80" r="30" fill="#8B4513" />
                
                <!-- Ears -->
                <polygon points="70,70 60,50 80,60" fill="#654321" />
                <polygon points="130,70 140,50 120,60" fill="#654321" />
                
                <!-- Eyes -->
                <circle cx="90" cy="75" r="5" fill="#FFFFFF" />
                <circle cx="110" cy="75" r="5" fill="#FFFFFF" />
                <circle cx="90" cy="75" r="2" fill="#000000" />
                <circle cx="110" cy="75" r="2" fill="#000000" />
                
                <!-- Nose -->
                <circle cx="100" cy="85" r="3" fill="#000000" />
                
                <!-- Mouth -->
                <path d="M95,90 Q100,95 105,90" stroke="#000000" stroke-width="1" fill="none" />
                
                <!-- Tail -->
                <path d="M150,130 Q160,120 150,110" stroke="#8B4513" stroke-width="5" fill="none" />
                
                <!-- Legs -->
                <rect x="80" y="150" width="10" height="30" fill="#8B4513" />
                <rect x="110" y="150" width="10" height="30" fill="#8B4513" />
            </svg>
            `),
            poodle: 'data:image/svg+xml;base64,' + btoa(`
            <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 300 300"
                width="300"
                height="300">
                <!-- Body -->
                <ellipse cx="150" cy="200" rx="60" ry="40" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="3" />

                <!-- Head -->
                <circle cx="150" cy="120" r="50" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="3" />

                <!-- Ears -->
                <path
                    d="M110,100 Q100,80 120,90 Q110,100 110,100"
                    fill="#FFFFFF"
                    stroke="#CCCCCC"
                    stroke-width="2" />
                <path
                    d="M190,100 Q200,80 180,90 Q190,100 190,100"
                    fill="#FFFFFF"
                    stroke="#CCCCCC"
                    stroke-width="2" />

                <!-- Eyes -->
                <circle cx="135" cy="115" r="5" fill="#000000" />
                <circle cx="165" cy="115" r="5" fill="#000000" />

                <!-- Pupils Glare -->
                <circle cx="134" cy="114" r="2" fill="#FFFFFF" />
                <circle cx="164" cy="114" r="2" fill="#FFFFFF" />

                <!-- Nose -->
                <circle cx="150" cy="130" r="4" fill="#000000" />

                <!-- Mouth -->
                <path d="M140,140 Q150,150 160,140" stroke="#000000" stroke-width="2" fill="none" />

                <!-- Curly Fur (Top of Head) -->
                <path
                    d="M100,120 Q90,100 150,90 Q210,100 200,120"
                    fill="#FFFFFF"
                    stroke="#CCCCCC"
                    stroke-width="2" />

                <!-- Curly Fur (Body) -->
                <path
                    d="M90,200 Q70,180 90,160 Q150,140 210,160 Q230,180 210,200"
                    fill="#FFFFFF"
                    stroke="#CCCCCC"
                    stroke-width="2" />

                <!-- Legs -->
                <rect x="120" y="220" width="10" height="40" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="2" />
                <rect x="170" y="220" width="10" height="40" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="2" />

                <!-- Paws -->
                <circle cx="125" cy="260" r="3" fill="#CCCCCC" />
                <circle cx="175" cy="260" r="3" fill="#CCCCCC" />

                <!-- Tail -->
                <path
                    d="M210,200 Q230,190 220,170"
                    stroke="#FFFFFF"
                    stroke-width="4"
                    fill="none"
                    stroke-linecap="round" />

                <!-- Bow -->
                <path
                    d="M130,90 Q150,80 170,90 Q160,100 150,90 Q140,100 130,90"
                    fill="#FF69B4"
                    stroke="#FF69B4"
                    stroke-width="2" />
            </svg>
            `)
        };

        // Preload images
        const loadedGroomingTable = new Promise((resolve) => {
            groomingTableImg.onload = () => resolve();
        });

        const loadedEnemy = new Promise((resolve) => {
            const enemyImg = new Image();
            enemyImg.src = enemyImageSrc;
            enemyImg.onload = () => resolve();
        });

        // Dog selection logic
        let selectedAvatar = null;
        avatarImages.forEach(img => {
            img.addEventListener('click', () => {
                avatarImages.forEach(image => image.classList.remove('selected'));
                img.classList.add('selected');
                selectedAvatar = img.getAttribute('data-avatar');
            });
        });

        // Start Game
        startButton.addEventListener('click', () => {
            if (selectedAvatar) {
                // Set player image based on selection
                player.image = new Image();
                player.image.src = dogAvatars[selectedAvatar];
                // Hide start screen and show controls
                startScreen.style.display = 'none';
                joystickContainer.style.display = 'block';
                actionButtons.style.display = 'block';
                // Start game after image loads
                player.image.onload = () => {
                    gameState = 'playing';
                    generateLevel();
                    requestAnimationFrame(gameLoop);
                };
            } else {
                alert('Please select a dog avatar to start the game!');
            }
        });

        // Resize Canvas
        function resizeCanvas() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            player.y = canvasHeight - player.height - 100;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Handling Input
        // Keyboard Controls
        document.addEventListener('keydown', function(e) {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', function(e) {
            keys[e.code] = false;
        });

        // Touch Joystick Controls
        const joystick = {
            active: false,
            initialX: 0,
            initialY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0
        };

        joystickContainer.addEventListener('touchstart', function(e) {
            e.preventDefault();
            joystick.active = true;
            joystick.initialX = e.touches[0].clientX;
            joystick.initialY = e.touches[0].clientY;
        });

        joystickContainer.addEventListener('touchmove', function(e) {
            if (!joystick.active) return;
            e.preventDefault();
            joystick.currentX = e.touches[0].clientX;
            joystick.currentY = e.touches[0].clientY;
            joystick.deltaX = joystick.currentX - joystick.initialX;
            joystick.deltaY = joystick.currentY - joystick.initialY;

            // Move joystick handle
            const maxDistance = 30;
            const distance = Math.sqrt(joystick.deltaX ** 2 + joystick.deltaY ** 2);
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                joystick.deltaX *= ratio;
                joystick.deltaY *= ratio;
            }
            joystickHandle.style.transform = `translate(${joystick.deltaX}px, ${joystick.deltaY}px)`;
        });

        joystickContainer.addEventListener('touchend', function(e) {
            e.preventDefault();
            joystick.active = false;
            joystick.deltaX = 0;
            joystick.deltaY = 0;
            joystickHandle.style.transform = `translate(0px, 0px)`;
        });

        // Action Buttons
        jumpButton.addEventListener('touchstart', e => {
            e.preventDefault();
            keys['Space'] = true;
        });
        jumpButton.addEventListener('touchend', e => {
            e.preventDefault();
            keys['Space'] = false;
        });

        shootButton.addEventListener('touchstart', e => {
            e.preventDefault();
            keys['KeyZ'] = true;
        });
        shootButton.addEventListener('touchend', e => {
            e.preventDefault();
            keys['KeyZ'] = false;
        });

        // Prevent Scrolling on Touch
        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        // Game Object Classes
        class Platform {
            constructor(x, y, width, height, type = 'static') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'static', 'moving'
                this.direction = 1; // For moving platforms
                this.speed = 2; // Movement speed
                this.moveRange = 100; // Range of movement
                this.initialX = x;
                this.initialY = y;
            }

            update() {
                if (this.type === 'moving') {
                    this.x += this.speed * this.direction;
                    // Change direction if platform reaches move range
                    if (this.x > this.initialX + this.moveRange) {
                        this.direction = -1;
                    } else if (this.x < this.initialX - this.moveRange) {
                        this.direction = 1;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.type === 'moving' ? 'orange' : 'brown';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Enemy {
            constructor(x, y, width, height, speed = 0, type = 'standard') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.direction = 1; // 1 for right, -1 for left
                this.patrolDistance = 100; // Distance to patrol from the initial position
                this.initialX = x; // Starting x position
                this.initialY = y;
                this.type = type; // 'standard', 'flying'
                this.bulletCooldown = 0; // For shooting enemies
                this.image = new Image();
                this.image.src = enemyImageSrc;
            }

            update() {
                if (this.type === 'flying') {
                    // Flying enemies move vertically
                    this.y += this.speed * this.direction;
                    // Change direction if enemy reaches patrol bounds
                    if (this.y > this.initialY + 50) {
                        this.direction = -1;
                    } else if (this.y < this.initialY - 50) {
                        this.direction = 1;
                    }

                    // Shooting mechanism for flying enemies
                    if (this.bulletCooldown > 0) {
                        this.bulletCooldown--;
                    } else {
                        // Fire a bark towards the player
                        const barkSpeed = 5;
                        const direction = player.x > this.x ? 1 : -1;
                        barks.push(new Bark(
                            this.x + this.width / 2,
                            this.y + this.height / 2,
                            20,
                            20,
                            barkSpeed * direction,
                            'enemy'
                        ));
                        this.bulletCooldown = 60; // Cooldown of 1 second (assuming 60 FPS)
                    }
                } else if (this.type === 'standard' && this.speed > 0) {
                    // Standard enemies patrol horizontally
                    this.x += this.speed * this.direction;
                    // Change direction if enemy reaches patrol bounds
                    if (this.x > this.initialX + this.patrolDistance) {
                        this.direction = -1;
                    } else if (this.x < this.initialX - this.patrolDistance) {
                        this.direction = 1;
                    }
                }
            }

            draw(ctx) {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }
        }

        class Bark {
            constructor(x, y, width, height, speed = 10, type = 'player') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.type = type; // 'player', 'enemy'
            }

            update() {
                this.x += this.speed;
            }

            draw(ctx) {
                if (this.type === 'player') {
                    ctx.fillStyle = '#8B4513'; // Brown color for player's bark
                } else {
                    ctx.fillStyle = '#FF4500'; // Orange-red for enemy's bark
                }
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Collectible {
            constructor(x, y, width, height, type = 'coin') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'coin', 'powerup'
                this.collected = false;
                this.image = null;
                if (this.type === 'coin') {
                    this.image = new Image();
                    this.image.src = 'https://via.placeholder.com/20?text=C'; // Placeholder Coin Image
                }
            }

            draw(ctx) {
                if (!this.collected && this.image.complete) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        class PowerUp {
            constructor(x, y, width, height, effect) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.effect = effect; // e.g., 'speed', 'invincibility'
                this.active = false;
                this.timer = 0;
                this.image = null;
                if (this.effect === 'speed') {
                    this.image = new Image();
                    this.image.src = 'https://via.placeholder.com/30?text=S'; // Placeholder Speed Power-Up Image
                } else if (this.effect === 'invincibility') {
                    this.image = new Image();
                    this.image.src = 'https://via.placeholder.com/30?text=I'; // Placeholder Invincibility Power-Up Image
                }
            }

            draw(ctx) {
                if (!this.active && this.image.complete) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        class Hazard {
            constructor(x, y, width, height, type = 'spike') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'spike', 'fire', etc.
                this.image = null;
                if (this.type === 'spike') {
                    this.image = new Image();
                    this.image.src = 'https://via.placeholder.com/30?text=S'; // Placeholder Spike Image
                }
            }

            draw(ctx) {
                if (this.image.complete) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        class FinishLine {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.image = new Image();
                this.image.src = finishLineImageSrc; // Finish Line SVG
            }

            draw(ctx) {
                if (this.image.complete) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        // Collision Detection Function
        function collisionCheck(player, obj) {
            return (
                player.x < obj.x + obj.width &&
                player.x + player.width > obj.x &&
                player.y < obj.y + obj.height &&
                player.y + player.height > obj.y
            );
        }

        // Level Progression and Reset Functions
        function levelUp() {
            gameState = 'levelcomplete';
            levelScoreElement.textContent = Math.floor(score);
            levelCompleteScreen.style.display = 'block';
        }

        function resetGame() {
            // Reset Player Position and States
            player.x = 50;
            player.y = canvasHeight - player.height - 100;
            player.velY = 0;
            player.jumping = false;
            player.grounded = false;
            player.invincible = false;
            player.invincibilityTimer = 0;

            // Reset Game Variables
            score = 0;
            level = 1;
            gameSpeed = 3;
            barks = []; // Reset barks
            cameraX = 0;
            barksAllowed = 3; // **Set to 3 for level 1**
            barksFired = 0;
            coinsCollected = 0;
            powerUpsCollected = 0;
            powerUps = [];

            // Hide Overlay Screens
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';

            // Show Controls
            joystickContainer.style.display = 'block';
            actionButtons.style.display = 'block';

            // Generate Level and Reset Game State
            generateLevel();
            gameState = 'playing';
            requestAnimationFrame(gameLoop);
        }

        function startNextLevel() {
            // Increment Level and Adjust Game Speed
            level++;
            gameSpeed += 1;

            // Reset Player Position and States
            player.x = 50;
            player.y = canvasHeight - player.height - 100;
            player.velY = 0;
            player.jumping = false;
            player.grounded = false;
            player.invincible = false;
            player.invincibilityTimer = 0;

            // Reset Level-Specific Variables
            barks = []; // Reset barks
            cameraX = 0;
            barksFired = 0;
            coinsCollected = 0;
            powerUpsCollected = 0;
            powerUps = [];

            // Generate New Level and Reset Game State
            generateLevel();
            levelCompleteScreen.style.display = 'none';
            gameState = 'playing';
            requestAnimationFrame(gameLoop);
        }

        // Generating Levels with New Mechanics
        function generateLevel() {
            platforms = [];
            enemies = [];
            barks = [];
            collectibles = [];
            powerUps = [];
            hazards = [];

            // Adjust worldWidth based on level
            if (level === 1) {
                worldWidth = baseWorldWidth; // First level is the base length
            } else {
                // Each subsequent level is 90% the length of the previous level, but not less than 2000
                worldWidth = Math.max(2000, baseWorldWidth - (level - 1) * 500);
            }

            // barksAllowed is already set to 3 from level 1 onwards

            // Reset counters
            coinsCollected = 0;
            powerUpsCollected = 0;

            // Create ground platform
            platforms.push(new Platform(0, canvasHeight - 100, worldWidth, 100));

            // Generate platforms with controlled vertical placement
            let previousPlatform = platforms[0];
            const minGapX = 200;
            const maxGapX = 400;
            const platformWidth = 100;
            const platformHeight = 20;

            // Calculate number of platforms based on worldWidth and horizontal gaps
            const numPlatforms = Math.floor(worldWidth / ((minGapX + maxGapX) / 2));

            for (let i = 0; i < numPlatforms; i++) {
                let gapX = minGapX + Math.random() * (maxGapX - minGapX);
                let x = previousPlatform.x + previousPlatform.width + gapX;

                // Ensure platforms do not exceed worldWidth
                if (x + platformWidth > worldWidth) break;

                // Calculate y position within jumpable range
                let maxY = previousPlatform.y + MAX_PLATFORM_HEIGHT_DIFF;
                let minY = previousPlatform.y - MAX_PLATFORM_HEIGHT_DIFF;

                // Clamp minY to not go below ground
                minY = Math.max(100, minY);

                let y = minY + Math.random() * (maxY - minY);

                // Ensure the platform is reachable
                y = Math.min(y, canvasHeight - 120); // Prevent platforms from being too low

                // Introduce moving platforms starting from level 2
                let platformType = 'static';
                if (level >= 2 && Math.random() < 0.3) { // 30% chance to be moving
                    platformType = 'moving';
                }

                platforms.push(new Platform(x, y, platformWidth, platformHeight, platformType));
                previousPlatform = platforms[platforms.length - 1];
            }

            // **Ensure some enemies spawn near the start**
            // Generate enemies with adequate spacing
            for (let i = 0; i < level * 3; i++) {
                let size = 50;
                let enemyType = 'standard';
                let speed = 1;
                let y = canvasHeight - 140;

                if (level > 5) {
                    enemyType = 'flying';
                    speed = 2 + Math.random() * 2; // Assign speed for moving enemies
                    y = 200 + Math.random() * (canvasHeight - 400);
                }

                // Attempt to place the enemy on a random platform, including initial platforms
                let placed = false;
                let attempts = 0;
                const maxAttempts = 100;

                while (!placed && attempts < maxAttempts) {
                    attempts++;
                    // Select a random platform, including initial platforms
                    let platform = platforms[Math.floor(Math.random() * platforms.length)];

                    // Calculate potential x position within platform bounds
                    let enemyX = platform.x + Math.random() * (platform.width - size);

                    // Check spacing with existing enemies
                    let tooClose = enemies.some(enemy => Math.abs(enemy.x - enemyX) < minEnemySpacing);

                    if (!tooClose) {
                        enemies.push(new Enemy(enemyX, y, size, size, speed, enemyType));
                        placed = true;
                    }
                }

                if (attempts === maxAttempts) {
                    console.warn('Failed to place enemy after maximum attempts.');
                }
            }

            // Generate collectibles (coins) starting from level 3
            if (level >= 3) {
                for (let i = 0; i < level * 5; i++) {
                    let size = 20;
                    let x = 100 + Math.random() * (worldWidth - 200);
                    // Place coins on platforms
                    let platform = platforms[Math.floor(Math.random() * platforms.length)];
                    let y = platform.y - size - 10; // Slightly above the platform
                    collectibles.push(new Collectible(x, y, size, size, 'coin'));
                }
            }

            // Generate power-ups starting from level 4
            if (level >= 4) {
                for (let i = 0; i < level; i++) {
                    let size = 30;
                    let x = 100 + Math.random() * (worldWidth - 200);
                    // Place power-ups on platforms
                    let platform = platforms[Math.floor(Math.random() * platforms.length)];
                    let y = platform.y - size - 10; // Slightly above the platform
                    // Randomly assign power-up types
                    let types = ['speed', 'invincibility'];
                    let effect = types[Math.floor(Math.random() * types.length)];
                    powerUps.push(new PowerUp(x, y, size, size, effect));
                }
            }

            // Generate environmental hazards starting from level 5
            if (level >= 5) {
                for (let i = 0; i < level * 2; i++) {
                    let size = 30;
                    let x = 100 + Math.random() * (worldWidth - 200);
                    // Place hazards on platforms
                    let platform = platforms[Math.floor(Math.random() * platforms.length)];
                    let y = platform.y - size / 2; // On top of the platform
                    hazards.push(new Hazard(x, y, size, size, 'spike'));
                }
            }

            // Generate finish line (grooming table)
            finishLine = new FinishLine(worldWidth - 150, canvasHeight - 200, 100, 100);
        }

        // Shooting Mechanism Changed to Barks
        function shoot() {
            if (barksAllowed > 0 && barksFired < barksAllowed) {
                barks.push(new Bark(
                    player.x + player.width,
                    player.y + player.height / 2 - 10, // Adjusted y position for better alignment
                    20, // Increased width for better visibility as a bark
                    20, // Increased height for better visibility as a bark
                    10,
                    'player'
                ));
                barksFired++;
                updateBarkCounter();
            }
        }

        // Update Bark Counter UI
        function updateBarkCounter() {
            barkCounter.textContent = `Barks: ${barksAllowed - barksFired}/${barksAllowed}`;
        }

        // Update Coin Counter UI
        function updateCoinCounter() {
            if (level >= 3) {
                coinCounter.textContent = `Coins: ${coinsCollected}`;
            } else {
                coinCounter.textContent = '';
            }
        }

        // Update Power-Up Counter UI
        function updatePowerUpCounter() {
            if (level >= 4) {
                powerUpCounter.textContent = `Power-Ups: ${powerUpsCollected}`;
            } else {
                powerUpCounter.textContent = '';
            }
        }

        // Apply Power-Up Effects
        function applyPowerUp(powerUp) {
            if (powerUp.effect === 'speed') {
                player.speed += 2;
                setTimeout(() => {
                    player.speed -= 2;
                }, 5000); // Speed boost lasts for 5 seconds
            } else if (powerUp.effect === 'invincibility') {
                player.invincible = true;
                player.invincibilityTimer = 300; // Frames of invincibility (5 seconds at 60 FPS)
            }
        }

        // Game Loop and Rendering
        function update() {
            if (gameState === 'playing') {
                // Move player with joystick input
                if (joystick.active) {
                    if (joystick.deltaX < -10) {
                        keys['ArrowLeft'] = true;
                        keys['ArrowRight'] = false;
                    } else if (joystick.deltaX > 10) {
                        keys['ArrowRight'] = true;
                        keys['ArrowLeft'] = false;
                    } else {
                        keys['ArrowLeft'] = false;
                        keys['ArrowRight'] = false;
                    }
                }

                // Move player with keyboard
                if (keys['ArrowLeft']) {
                    player.x -= player.speed;
                }
                if (keys['ArrowRight']) {
                    player.x += player.speed;
                }

                // Jumping
                if (keys['Space'] && !player.jumping && player.grounded) {
                    player.velY = jumpVelocity; // Set initial jump velocity
                    player.jumping = true;
                    player.grounded = false;
                }

                player.velY += gravity; // Gravity
                player.y += player.velY;

                // Collision Detection with Platforms
                player.grounded = false;
                platforms.forEach(platform => {
                    if (collisionCheck(player, platform)) {
                        player.grounded = true;
                        player.jumping = false;
                        player.velY = 0;
                        player.y = platform.y - player.height;
                    }
                });

                // Prevent going off-world
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
                if (player.y > canvasHeight) {
                    // Player fell off the screen
                    gameState = 'gameover';
                    finalScoreElement.textContent = Math.floor(score);
                    gameOverScreen.style.display = 'block';
                }

                // Update enemies
                enemies.forEach(enemy => {
                    enemy.update();

                    // Collision with player
                    if (collisionCheck(player, enemy)) {
                        if (!player.invincible) {
                            gameState = 'gameover';
                            finalScoreElement.textContent = Math.floor(score);
                            gameOverScreen.style.display = 'block';
                        }
                    }
                });

                // Update barks
                barks.forEach((bark, index) => {
                    bark.update();
                    // Remove barks off-world
                    if (bark.x > worldWidth || bark.x < 0) {
                        barks.splice(index, 1);
                        return;
                    }
                    // Bark and enemy collision
                    if (bark.type === 'player') {
                        enemies.forEach((enemy, eIndex) => {
                            if (collisionCheck(bark, enemy)) {
                                enemies.splice(eIndex, 1);
                                barks.splice(index, 1);
                                score += 1;
                            }
                        });
                    } else if (bark.type === 'enemy') {
                        if (collisionCheck(bark, player)) {
                            if (!player.invincible) {
                                gameState = 'gameover';
                                finalScoreElement.textContent = Math.floor(score);
                                gameOverScreen.style.display = 'block';
                            }
                            barks.splice(index, 1);
                        }
                    }
                });

                // Update platforms (moving platforms)
                platforms.forEach(platform => {
                    platform.update();
                });

                // Update collectibles (coins)
                collectibles.forEach((collectible, index) => {
                    if (collisionCheck(player, collectible) && !collectible.collected) {
                        collectible.collected = true;
                        coinsCollected++;
                        score += 5; // Each coin adds 5 points
                    }
                });

                // Update power-ups
                powerUps.forEach((powerUp, index) => {
                    if (collisionCheck(player, powerUp) && !powerUp.active) {
                        powerUp.active = true;
                        powerUpsCollected++;
                        applyPowerUp(powerUp);
                    }
                });

                // Update hazards
                hazards.forEach(hazard => {
                    if (collisionCheck(player, hazard)) {
                        if (!player.invincible) {
                            gameState = 'gameover';
                            finalScoreElement.textContent = Math.floor(score);
                            gameOverScreen.style.display = 'block';
                        }
                    }
                });

                // Update finish line
                if (collisionCheck(player, finishLine)) {
                    levelUp();
                }

                // Update camera position
                cameraX = player.x - canvasWidth / 2 + player.width / 2;
                if (cameraX < 0) cameraX = 0;
                if (cameraX > worldWidth - canvasWidth) cameraX = worldWidth - canvasWidth;

                // Handle shooting input
                if (keys['KeyZ']) { // **Enabled shooting from Level 1**
                    shoot();
                    keys['KeyZ'] = false; // Prevent continuous shooting
                }

                // Update invincibility timer
                if (player.invincible) {
                    player.invincibilityTimer--;
                    if (player.invincibilityTimer <= 0) {
                        player.invincible = false;
                    }
                }

                // Update UI counters
                updateBarkCounter();
                updateCoinCounter();
                updatePowerUpCounter();
            }

            // Update invincibility timer outside of 'playing' state
            if (player.invincible) {
                player.invincibilityTimer--;
                if (player.invincibilityTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Update UI counters regardless of game state
            updateBarkCounter();
            updateCoinCounter();
            updatePowerUpCounter();
        }

        function render() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Save the current context before applying transformations
            ctx.save();

            // Translate the canvas to simulate camera movement
            ctx.translate(-cameraX, 0);

            // Draw platforms
            platforms.forEach(platform => {
                platform.draw(ctx);
            });

            // Draw enemies
            enemies.forEach(enemy => {
                enemy.draw(ctx);
            });

            // Draw barks
            barks.forEach(bark => {
                bark.draw(ctx);
            });

            // Draw collectibles (coins)
            collectibles.forEach(collectible => {
                collectible.draw(ctx);
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                powerUp.draw(ctx);
            });

            // Draw hazards (spikes)
            hazards.forEach(hazard => {
                hazard.draw(ctx);
            });

            // Draw finish line (grooming table)
            finishLine.draw(ctx);

            // Draw player
            if (player.image.complete) {
                if (player.invincible) {
                    ctx.globalAlpha = 0.7; // Slight transparency when invincible
                }
                ctx.drawImage(player.image, player.x, player.y, player.width, player.height);
                ctx.globalAlpha = 1.0; // Reset alpha
            }

            // Restore the context to original state
            ctx.restore();

            // Draw UI elements (score and level)
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${Math.floor(score)}`, 20, 30);
            ctx.fillText(`Level: ${level}`, 20, 60);

            // Draw UI Counters
            // Counters are handled by HTML elements

            // Draw Game State Messages
            if (gameState === 'gameover') {
                // Overlay is already handled by the gameOverScreen div
            } else if (gameState === 'levelcomplete') {
                // Overlay is already handled by the levelCompleteScreen div
            }
        }

        function gameLoop() {
            update();
            render();
            if (gameState === 'playing') {
                requestAnimationFrame(gameLoop);
            }
        }

        // Handle Canvas Clicks for Restart and Next Level
        canvas.addEventListener('click', function() {
            if (gameState === 'gameover') {
                resetGame();
            } else if (gameState === 'levelcomplete') {
                startNextLevel();
            }
        });

        // Handle Touch Events for Restart and Next Level
        canvas.addEventListener('touchstart', function(e) {
            if (gameState === 'gameover') {
                resetGame();
            } else if (gameState === 'levelcomplete') {
                startNextLevel();
            }
        });

        // Preload images and start the game when ready
        window.onload = function() {
            // Preload grooming table and enemy images
            Promise.all([loadedGroomingTable, loadedEnemy]).then(() => {
                // Images are loaded, ready to start when player chooses
                console.log('All images loaded successfully.');
            }).catch(err => {
                console.error('Error loading images:', err);
            });
        };
    </script>

</body>
</html>
